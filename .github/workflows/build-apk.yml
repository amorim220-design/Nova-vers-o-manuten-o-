name: Build Android APK (Capacitor Signed)

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash


    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install

      - name: Build web (Vite)
        run: npm run build

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Read version.json
        run: |
          VERSION_CODE=$(node -p "require('./version.json').versionCode")
          VERSION_NAME=$(node -p "require('./version.json').version")

          if [ -z "$VERSION_CODE" ] || [ -z "$VERSION_NAME" ]; then
            echo "version.json precisa ter version e versionCode"
            exit 1
          fi

          echo "VERSION_CODE=$VERSION_CODE" >> $GITHUB_ENV
          echo "VERSION_NAME=$VERSION_NAME" >> $GITHUB_ENV
          echo "Version OK: $VERSION_NAME ($VERSION_CODE)"

      - name: Recreate Android platform
        run: |
          rm -rf android
          npx cap add android

      - name: Sync Capacitor
        run: npx cap sync android

      - name: Decode keystore (Node safe)
        shell: bash
        env:
          KS: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
        run: |
          node -e "const fs=require('fs'); const b=process.env.KS||''; if(!b) {console.error('ANDROID_KEYSTORE_BASE64 vazio'); process.exit(1);} fs.mkdirSync('android/app',{recursive:true}); fs.writeFileSync('android/app/release.jks', Buffer.from(b,'base64')); console.log('Keystore OK:', fs.statSync('android/app/release.jks').size, 'bytes');"


          - name: Verify keystore (list aliases)
            run: |
              keytool -list -v -keystore android/app/release.jks -storepass "${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" | sed -n '1,120p'


      # ðŸ”¥ PATCH: ForÃ§a o build.gradle a assinar usando env vars (funciona mesmo recriando android/)
      - name: Patch Gradle signing config
        run: |
          APP_GRADLE="android/app/build.gradle"

          # Remove blocos antigos de signing (se existirem) para evitar duplicaÃ§Ã£o
          perl -0777 -i -pe 's/signingConfigs\s*\{.*?\}\s*//gs' "$APP_GRADLE"

          # Garante que buildTypes.release usa signingConfig release
          perl -0777 -i -pe 's/buildTypes\s*\{\s*release\s*\{(.*?)\}\s*\}/buildTypes {\n        release {\1\n            signingConfig signingConfigs.release\n        }\n    }/gs' "$APP_GRADLE"

          # Insere signingConfigs dentro do android { ... } (logo apÃ³s "android {")
          perl -0777 -i -pe 's/android\s*\{\s*/android {\n    signingConfigs {\n        release {\n            storeFile file(\"release.jks\")\n            storePassword System.getenv(\"ANDROID_KEYSTORE_PASSWORD\")\n            keyAlias System.getenv(\"ANDROID_KEY_ALIAS\")\n            keyPassword System.getenv(\"ANDROID_KEY_PASSWORD\")\n        }\n    }\n\n/gs' "$APP_GRADLE"

      - name: Build RELEASE APK (signed)
        run: |
          cd android
          chmod +x gradlew
          ./gradlew assembleRelease -x test \
            -PVERSION_CODE=$VERSION_CODE \
            -PVERSION_NAME=$VERSION_NAME
        env:
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}

      # ðŸ”Ž DiagnÃ³stico: lista tudo que foi gerado
      - name: List APK outputs
        run: |
          echo "==== APK files ===="
          find android/app/build/outputs/apk -name "*.apk" -print || true
          echo "==== Bundle files (if any) ===="
          find android/app/build/outputs -name "*.aab" -print || true

      # âœ… Pega preferencialmente o assinado, mas se sÃ³ tiver unsigned mostra claramente
      - name: Find APK
        run: |
          APK_SIGNED=$(find android/app/build/outputs/apk/release -name "*.apk" ! -name "*unsigned*" | head -n 1)
          APK_ANY=$(find android/app/build/outputs/apk/release -name "*.apk" | head -n 1)

          if [ -n "$APK_SIGNED" ]; then
            APK_PATH="$APK_SIGNED"
            echo "APK assinado encontrado: $APK_PATH"
          else
            echo "APK assinado nÃ£o encontrado."
            echo "Se existir apenas *unsigned*, entÃ£o a assinatura nÃ£o foi aplicada."
            echo "APKs encontrados:"
            find android/app/build/outputs/apk/release -name "*.apk" -print || true

            if [ -z "$APK_ANY" ]; then
              echo "Nenhum APK release foi gerado."
              exit 1
            fi

            # Se quiser falhar sempre quando nÃ£o assinar, deixe exit 1 aqui.
            # exit 1

            # Se quiser continuar mesmo unsigned, comente o exit acima e use:
            APK_PATH="$APK_ANY"
            echo "Usando APK (provavelmente unsigned): $APK_PATH"
          fi

          echo "APK_PATH=$APK_PATH" >> $GITHUB_ENV

      - name: Rename APK
        run: |
          mv "$APK_PATH" "manutencao-apartamentos-v$VERSION_NAME.apk"

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: apk-release
          path: manutencao-apartamentos-v*.apk
